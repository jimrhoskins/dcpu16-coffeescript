// Generated by CoffeeScript 1.3.1
(function() {
  var Assembler, CODE, Machine, assemble, bin, cleanLine, dump, hex, machine, print, rl, _bin,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  hex = function(n) {
    var s;
    n = n || 0;
    s = "000" + n.toString(16);
    return s.slice(s.length - 4);
  };

  bin = function(n) {
    var s;
    s = "000000000000000" + n.toString(2);
    return s.slice(s.length - 16);
  };

  _bin = function(str) {
    return parseInt(str, 2);
  };

  Machine = (function() {

    Machine.name = 'Machine';

    Machine.prototype.OPCODES = ["$OP", "SET", "ADD", "SUB", "MUL", "DIV", "MOD", "SHL", "SHR", "AND", "BOR", "XOR", "IFE", "IFN", "IFG", "IFB"];

    Machine.prototype.EXTENDED_OPCODES = [null, "JSR", "BRK"];

    function Machine(program, verbose) {
      this.program = program;
      this.verbose = verbose != null ? verbose : false;
      this.reset();
    }

    Machine.prototype.mem = function(index, val) {
      if (val != null) {
        val = val & 0xffff;
        if (index >= 0x8000 && index < 0x8200 && (this.memory[index] || 0) !== val) {
          this.videoDirty = true;
        }
        this.memory[index] = val;
        return val;
      } else {
        return this.memory[index] || 0;
      }
    };

    Machine.prototype.reset = function() {
      var data;
      this.memory = (function() {
        var _i, _len, _ref, _results;
        _ref = this.program;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _results.push(data);
        }
        return _results;
      }).call(this);
      this.exited = false;
      this.videoDirty = true;
      return this.register = {
        A: 0,
        B: 0,
        C: 0,
        X: 0,
        Y: 0,
        Z: 0,
        I: 0,
        J: 0,
        PC: 0,
        SP: 0,
        O: 0
      };
    };

    Machine.prototype.decompile = function() {
      var a, b, code, i, op, _i, _len, _ref, _ref1;
      this.decompiling = true;
      this.instructions = [];
      while (this.register.PC < this.memory.length) {
        this.step();
      }
      code = "";
      _ref = this.instructions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], op = _ref1[0], a = _ref1[1], b = _ref1[2];
        i = "" + op + " " + a.repr;
        if (b) {
          i += ", " + b.repr;
        }
        code += i + "\n";
      }
      delete this.decompiling;
      delete this.instructions;
      return code;
    };

    Machine.prototype.nextWord = function() {
      this.register.PC += 1;
      return this.memory[this.register.PC - 1];
    };

    Machine.prototype.step = function() {
      var a, b, instruction, op;
      instruction = this.nextWord();
      op = this.getOp(instruction & 0x0f);
      if (op === "$OP") {
        op = this.EXTENDED_OPCODES[(instruction >> 4) & 0x3f];
        a = this.getValue((instruction >> 10) & 0x3f);
        b = void 0;
      } else {
        a = this.getValue((instruction >> 4) & 0x3f);
        b = this.getValue((instruction >> 10) & 0x3f);
      }
      return this.exec(op, a, b);
    };

    Machine.prototype.exec = function() {
      var a, args, op, _ref;
      op = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.decompiling) {
        this.instructions.push([op].concat(__slice.call(args)));
        return;
      }
      if (this.skipNext) {
        this.skipNext = false;
        return;
      }
      if (op != null) {
        if (this.verbose) {
          console.log(op, ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = args.length; _i < _len; _i++) {
              a = args[_i];
              if (a != null) {
                _results.push(a.repr);
              }
            }
            return _results;
          })()).join(', '));
        }
        return (_ref = this[op]).call.apply(_ref, [this].concat(__slice.call(args)));
      } else {
        if (this.verbose) {
          return console.log('~SKIP~', op, ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = args.length; _i < _len; _i++) {
              a = args[_i];
              if (a != null) {
                _results.push(a.repr);
              }
            }
            return _results;
          })()).join(', '));
        }
      }
    };

    Machine.prototype.pop = function() {
      var val;
      val = this.peek();
      this.register.SP = (this.register.SP + 1) & 0xffff;
      return val;
    };

    Machine.prototype.peek = function() {
      return this.memory[this.register.SP];
    };

    Machine.prototype.push = function(val) {
      this.register.SP = (this.register.SP - 1) & 0xffff;
      return this.memory[this.register.SP] = val & 0xffff;
    };

    Machine.prototype.getOp = function(number) {
      return this.OPCODES[number];
    };

    Machine.prototype.getValue = function(raw) {
      var get, key, repr, set, value, _i, _j, _k, _l, _results, _results1, _results2, _results3,
        _this = this;
      get = set = null;
      switch (true) {
        case __indexOf.call((function() {
            _results = [];
            for (var _i = 0x00; 0x00 <= 0x07 ? _i <= 0x07 : _i >= 0x07; 0x00 <= 0x07 ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this), raw) >= 0:
          key = "ABCXYZIJ".charAt(raw);
          get = function() {
            return _this.register[key];
          };
          set = function(val) {
            return _this.register[key] = val;
          };
          repr = key;
          break;
        case __indexOf.call((function() {
            _results1 = [];
            for (var _j = 0x08; 0x08 <= 0x0f ? _j <= 0x0f : _j >= 0x0f; 0x08 <= 0x0f ? _j++ : _j--){ _results1.push(_j); }
            return _results1;
          }).apply(this), raw) >= 0:
          key = "ABCXYZIJ".charAt(raw - 0x08);
          get = function() {
            return _this.mem(_this.register[key]) || 0;
          };
          set = function(val) {
            return _this.mem(_this.register[key], val);
          };
          repr = "[" + key + "]";
          break;
        case __indexOf.call((function() {
            _results2 = [];
            for (var _k = 0x10; 0x10 <= 0x17 ? _k <= 0x17 : _k >= 0x17; 0x10 <= 0x17 ? _k++ : _k--){ _results2.push(_k); }
            return _results2;
          }).apply(this), raw) >= 0:
          value = this.nextWord() || 0;
          key = "ABCXYZIJ".charAt(raw - 0x10);
          get = function() {
            return _this.mem(value + _this.register[key]) || 0;
          };
          set = function(val) {
            return _this.mem(value + _this.register[key], val);
          };
          repr = "[0x" + (value.toString(16)) + "+" + key + "]";
          break;
        case raw === 0x18:
          value = this.pop();
          get = function() {
            return value;
          };
          set = function() {};
          repr = "POP";
          break;
        case raw === 0x19:
          value = this.peek();
          get = function() {
            return value;
          };
          set = function(val) {
            return _this.mem(_this.register.SP, val & 0xff);
          };
          repr = "PEEK";
          break;
        case raw === 0x1a:
          get = function() {};
          set = function(val) {
            return _this.push(val);
          };
          repr = "PUSH";
          break;
        case raw === 0x1b:
          get = function() {
            return _this.register.SP;
          };
          set = function(val) {
            return _this.register.SP = val;
          };
          repr = "SP";
          break;
        case raw === 0x1c:
          get = function() {
            return _this.register.PC;
          };
          set = function(val) {
            return _this.register.PC = val;
          };
          repr = "PC";
          break;
        case raw === 0x1d:
          get = function() {
            return _this.register.O;
          };
          set = function(val) {
            return _this.register.O = val;
          };
          repr = "O";
          break;
        case raw === 0x1e:
          value = this.nextWord() || 0;
          get = function() {
            return _this.mem(value) || 0;
          };
          set = function(val) {
            return _this.mem(value, val);
          };
          repr = "[0x" + (value.toString(16)) + "]";
          break;
        case raw === 0x1f:
          value = this.nextWord() || 0;
          get = function() {
            return value;
          };
          set = function() {};
          repr = "0x" + (value.toString(16));
          break;
        case __indexOf.call((function() {
            _results3 = [];
            for (var _l = 0x20; 0x20 <= 0x3f ? _l <= 0x3f : _l >= 0x3f; 0x20 <= 0x3f ? _l++ : _l--){ _results3.push(_l); }
            return _results3;
          }).apply(this), raw) >= 0:
          value = raw - 0x20;
          get = function() {
            return value;
          };
          set = function() {};
          repr = "0x" + (value.toString(16));
      }
      if (!(get && set)) {
        throw "Uh oh " + raw;
      }
      return {
        raw: raw,
        get: get,
        set: set,
        repr: repr
      };
    };

    Machine.prototype.JSR = function(a) {
      this.push(this.register.PC);
      return this.register.PC = a.get();
    };

    Machine.prototype.BRK = function(a) {
      return this.exited = a.get();
    };

    Machine.prototype.SET = function(a, b) {
      return a.set(b.get());
    };

    Machine.prototype.ADD = function(a, b) {
      var sum;
      sum = a.get() + b.get();
      if (sum > 0xffff) {
        this.register.O = 0x0001;
      } else {
        this.register.O = 0x0;
      }
      return a.set(sum & 0xffff);
    };

    Machine.prototype.SUB = function(a, b) {
      var result;
      result = a.get() - b.get();
      if (result < 0) {
        this.register.O = 0xffff;
      } else {
        this.register.O = 0x0;
      }
      return a.set(result & 0xffff);
    };

    Machine.prototype.MUL = function(a, b) {
      var result;
      result = a.get() * b.get();
      this.register.O = (result >> 16) & 0xffff;
      return a.set(result & 0xffff);
    };

    Machine.prototype.DIV = function(a, b) {
      var result;
      if (b.get() === 0) {
        a.set(0x0);
        return this.register.O = 0x0;
      } else {
        result = a / b;
        this.register.O = ((a.get() << 16) / b.get()) & 0xffff;
        return a.set(result & 0xffff);
      }
    };

    Machine.prototype.MOD = function(a, b) {
      if (b.get() === 0) {
        return a.set(0);
      } else {
        return a.set((a % b) & 0xffff);
      }
    };

    Machine.prototype.SHL = function(a, b) {
      this.register.O = ((a.get() << b.get()) >> 16) & 0xffff;
      return a.set((a.get() << b.get()) & 0xffff);
    };

    Machine.prototype.SHR = function(a, b) {
      this.register.O = ((a.get() << 16) >> b.get()) & 0xffff;
      return a.set((a.get() >> b.get()) & 0xffff);
    };

    Machine.prototype.AND = function(a, b) {
      return a.set(a.get() & b.get());
    };

    Machine.prototype.BOR = function(a, b) {
      return a.set(a.get() | b.get());
    };

    Machine.prototype.XOR = function(a, b) {
      return a.set(a.get() ^ b.get());
    };

    Machine.prototype.IFE = function(a, b) {
      if (a.get() !== b.get()) {
        return this.skipNext = true;
      }
    };

    Machine.prototype.IFN = function(a, b) {
      if (a.get() === b.get()) {
        return this.skipNext = true;
      }
    };

    Machine.prototype.IFG = function(a, b) {
      if (!(a.get() > b.get())) {
        return this.skipNext = true;
      }
    };

    Machine.prototype.IFB = function(a, b) {
      if ((a.get() & b.get()) === 0) {
        return this.skipNext = true;
      }
    };

    return Machine;

  })();

  Assembler = (function() {

    Assembler.name = 'Assembler';

    Assembler.prototype.OPS = {
      SET: 0x01,
      ADD: 0x02,
      SUB: 0x03,
      MUL: 0x04,
      DIV: 0x05,
      MOD: 0x06,
      SHL: 0x07,
      SHR: 0x08,
      AND: 0x09,
      BOR: 0x0a,
      XOR: 0x0b,
      IFE: 0x0c,
      IFN: 0x0d,
      IFG: 0x0e,
      IFB: 0x0f,
      JSR: 0x10,
      BRK: 0x20
    };

    Assembler.prototype.REGISTERS = {
      A: 0x00,
      B: 0x01,
      C: 0x02,
      X: 0x03,
      Y: 0x04,
      Z: 0x05,
      I: 0x06,
      J: 0x07,
      POP: 0x18,
      PEEK: 0x19,
      PUSH: 0x1a,
      SP: 0x1b,
      PC: 0x1c,
      O: 0x1d
    };

    function Assembler(code) {
      this.code = code;
      this.instructions = [];
      this.labels = {};
      this.read();
      console.log(this.instructions);
      console.log(this.labels);
      this.compile();
    }

    Assembler.prototype.read = function() {
      var args, label, line, lines, op, rawLine, token, tokens, _i, _j, _len, _len1, _results;
      lines = this.code.split(/\n+/);
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        rawLine = lines[_i];
        line = this.cleanLine(rawLine);
        if (!line.length) {
          continue;
        }
        tokens = this.split(line);
        op = null;
        args = [];
        for (_j = 0, _len1 = tokens.length; _j < _len1; _j++) {
          token = tokens[_j];
          if (token.toUpperCase() === 'DAT') {
            op = 'DAT';
            args = this.readData(rawLine);
            break;
          } else if (this.isLabel(token)) {
            label = token.slice(1);
            if (label in this.labels) {
              this.crash("Duplicate label " + label);
            } else {
              this.labels[token.slice(1)] = this.instructions.length;
            }
          } else if (this.isOp(token) && !op) {
            op = token.toUpperCase();
          } else if (op) {
            args.push(token);
          } else {
            this.crash("Don't know what to do with " + token + " in " + line);
          }
        }
        if (op) {
          _results.push(this.instructions.push([op].concat(__slice.call(args))));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Assembler.prototype.readData = function(line) {
      var after, c, char, i, inquotes, result, slashLength, token, tokenIsString, values, _i, _j, _k, _len, _len1, _len2, _ref;
      result = line.match(/[\s^](dat)\s/i);
      after = line.substr(result.index + result[0].length, line.length);
      values = [];
      token = '';
      inquotes = false;
      slashLength = 0;
      for (i = _i = 0, _len = after.length; _i < _len; i = ++_i) {
        char = after[i];
        if (char === '\\') {
          slashLength += 1;
        } else if (char !== '"') {
          slashLength = 0;
        }
        if (inquotes) {
          if (char === '"' && slashLength % 2 === 0) {
            inquotes = false;
            _ref = token.split('');
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              c = _ref[_j];
              values.push(c.charCodeAt());
            }
            token = '';
            continue;
          }
          if (char === '\\' && slashLength && slashLength % 2 === 1) {
            continue;
          } else {
            token += char;
          }
        } else {
          if (char === '"') {
            if (tokenIsString) {
              throw "Unnexpected token \"";
            }
            inquotes = true;
            tokenIsString = true;
            continue;
          }
          if (char === ',' || char === ' ' || char === '\t') {
            if (token) {
              if (tokenIsString) {
                for (_k = 0, _len2 = token.length; _k < _len2; _k++) {
                  char = token[_k];
                  values.push(char.charCodeAt());
                }
              } else {
                if (!tokenIsString) {
                  token = parseInt(token);
                }
                if (isNaN(token)) {
                  throw "Cannot parse token " + token;
                }
                values.push(token);
              }
              token = '';
              tokenIsString = false;
            }
            continue;
          }
          if (char === ';') {
            if (token) {
              values.push(token);
            }
            break;
          } else {
            token += char;
          }
        }
      }
      if (inquotes) {
        throw 'Mismatched quotes';
      }
      if (token.length) {
        values.push(token);
      }
      return values;
    };

    Assembler.prototype.compile = function() {
      var address, arg, args, code, i, instructionMap, label, labelFixes, literal, next, op, pointer, register, shift, word, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;
      instructionMap = {};
      labelFixes = [];
      this.program = [];
      _ref = this.instructions;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        _ref1 = _ref[i], op = _ref1[0], args = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
        instructionMap[i] = this.program.length;
        if (op.toUpperCase() === 'DAT') {
          (_ref2 = this.program).push.apply(_ref2, args);
          continue;
        }
        word = 0;
        word |= this.OPS[op];
        next = [];
        shift = -2;
        if ((word & 0xf) === 0) {
          shift = 4;
        }
        for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
          arg = args[_j];
          shift += 6;
          _ref3 = this.checkForPointer(arg), pointer = _ref3[0], arg = _ref3[1];
          label = false;
          if (arg.indexOf('+') !== -1) {
            _ref4 = arg.replace(/\s+/g, '').split('+'), literal = _ref4[0], register = _ref4[1];
            if (this.REGISTERS[literal.toUpperCase()] != null) {
              _ref5 = [register, literal], literal = _ref5[0], register = _ref5[1];
            }
            if (this.labels[literal] != null) {
              console.log('lit add at', this.program.length - 1, arg);
              literal = this.labels[literal];
              labelFixes.push(this.program.length + next.length + 1);
            } else {
              literal = parseInt(literal);
              if (isNaN(literal)) {
                this.crash('Bad iteral in ' + op + args + "~~~" + literal + '~' + register);
              }
            }
            code = this.REGISTERS[register.toUpperCase()] + 0x10;
            word |= code << shift;
            next.push(literal);
            continue;
          }
          if (arg.toUpperCase() in this.REGISTERS && this.REGISTERS[arg.toUpperCase()] > 0x07) {
            code = this.REGISTERS[arg.toUpperCase()];
            word |= code << shift;
            continue;
          }
          if (arg.toUpperCase() in this.REGISTERS && this.REGISTERS[arg.toUpperCase()] <= 0x07) {
            code = this.REGISTERS[arg.toUpperCase()];
            if (pointer) {
              code += 0x08;
            }
            word |= code << shift;
            continue;
          }
          literal = null;
          if (this.labels[arg] != null) {
            label = true;
            literal = this.labels[arg];
            labelFixes.push(this.program.length + next.length + 1);
          } else {
            literal = parseInt(arg);
          }
          if ((literal != null) && !isNaN(literal)) {
            if (literal > 0x1f || label) {
              code = 0x1e;
              if (!pointer) {
                code += 1;
              }
              next.push(literal);
            } else {
              code = literal + 0x20;
            }
            word |= code << shift;
            continue;
          }
        }
        this.program.push(word);
        (_ref6 = this.program).push.apply(_ref6, next);
      }
      _results = [];
      for (_k = 0, _len2 = labelFixes.length; _k < _len2; _k++) {
        address = labelFixes[_k];
        _results.push(this.program[address] = instructionMap[this.program[address]]);
      }
      return _results;
    };

    Assembler.prototype.checkForPointer = function(arg) {
      var match;
      match = arg.match(/^\[\s*(.+)\s*\]$/);
      if (match) {
        return [true, match[1]];
      } else {
        return [false, arg];
      }
    };

    Assembler.prototype.cleanLine = function(line) {
      return line.replace(/;.*$/, '').replace(/(^\s+)|(\s+$)/g, '').replace(/[,\s]+/g, ' ').replace(/\[\s+/g, '[').replace(/\s\]+/g, ']').replace(/\s*\+\s*/g, '+');
    };

    Assembler.prototype.split = function(line) {
      return line.split(' ');
    };

    Assembler.prototype.isLabel = function(token) {
      return token.match(/^:[-_a-z0-9]+$/i);
    };

    Assembler.prototype.isOp = function(token) {
      return token.toUpperCase() in this.OPS;
    };

    Assembler.prototype.crash = function(message) {
      if (message == null) {
        message = 'Unknown Error';
      }
      throw message;
    };

    return Assembler;

  })();

  cleanLine = function() {
    return [0, 0, 0, 0, 0, 0, 0, 0];
  };

  print = function(memory) {
    var address, col, line, lineno, lines, word, _i, _j, _len, _len1;
    console.log("\n--------------- Memory Dump -----------------");
    lines = [];
    for (address = _i = 0, _len = memory.length; _i < _len; address = ++_i) {
      word = memory[address];
      if (!word) {
        continue;
      }
      line = Math.floor(address / 8);
      col = address % 8;
      if (lines[line] == null) {
        lines[line] = cleanLine();
      }
      lines[line][col] = word;
    }
    for (lineno = _j = 0, _len1 = lines.length; _j < _len1; lineno = ++_j) {
      line = lines[lineno];
      if (!line) {
        continue;
      }
      console.log(hex(lineno * 8) + ": " + ((function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = line.length; _k < _len2; _k++) {
          word = line[_k];
          _results.push(hex(word));
        }
        return _results;
      })()).join(" "));
    }
    return console.log("---------------------------------------------");
  };

  CODE = "\n;basic stuff\n              set a, 0x30              ; 7c01 0030\n              set [0x1000], 0x20       ; 7de1 1000 0020\n              sub a, [0x1000]          ; 7803 1000\n              ifn a, 0x10              ; c00d \n                 set pc, crash         ; 7dc1 001a [*]\n\n; do a loopy thing\n              set i, 10                ; a861\n              set a, 0x2000            ; 7c01 2000\n:loop         set [0x2000+i], [a]      ; 2161 2000\n              sub i, 1                 ; 8463\n              ifn i, 0                 ; 806d\n                 set pc, loop          ; 7dc1 000d [*]\n\n; call a subroutine\n              set x, 0x4               ; 9031\n              jsr testsub              ; 7c10 0018 [*]\n              set pc, crash            ; 7dc1 001a [*]\n\n:testsub      shl x, 4                 ; 9037\n              set pc, pop              ; 61c1\n                \n; hang forever. x should now be 0x40 if everything went right.\n:crash        set pc, crash            ; 7dc1 001a [*]\n\n:dat       dat 0xdead, \"h;el\\\\\\\\\\\"lo\", 0xdead 100 ;annoying comment\n\n; [*]: note that these can be one word shorter and one cycle faster by using the short form (0x00-0x1f) of literals,\n;      but my assembler doesn't support short form labels yet.";

  CODE = "";

  dump = function(machine) {
    var x;
    console.log(((function() {
      var _i, _len, _ref, _results;
      _ref = "ABCXYZIJ".split('');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(" " + x + "  ");
      }
      return _results;
    })()).join('|') + "| PC | SP | O");
    return console.log(((function() {
      var _i, _len, _ref, _results;
      _ref = "A B C X Y Z I J PC SP O".split(' ');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(hex(machine.register[x]));
      }
      return _results;
    })()).join('|'));
  };

  assemble = function(code) {
    return (new Assembler(code)).program;
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = {
      Assembler: Assembler,
      Machine: Machine,
      assemble: assemble,
      hex: hex,
      print: print,
      dump: dump
    };
  }

  if (require.main === module) {
    rl = require('readline').createInterface(process.stdin, process.stdout);
    machine = new Machine(assemble(CODE), true);
    dump(machine);
    rl.on('line', function() {
      machine.step();
      print(machine.memory);
      dump(machine);
      return console.log('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
    });
  }

}).call(this);
